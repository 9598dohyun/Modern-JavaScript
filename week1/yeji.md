## 범위

4장~7장

# 4장: 변수

- 변수 = 하나의 값을 저장하기 위해 확보한 메모리 공간 그 자체 || 메모리 공간을 식별하기 위해 붙인 이름
- 식별자 = 변수 이름, 메모리 주소를 기억
- 변수 선언 후 값을 할당하지 않을 경우 -> undefined 로 할당
- ReferenceError: 선언하지 않은 식별자에 접근했을 때

## 변수 호이스팅 vs 값의 할당

변수 선언은 런타임이 아닌 **그 이전 단계**에서 실행

```
console.log(score); //undefined
var score;
```

값의 할당은 **런타임**에 실행

```
console.log(score); // undefined
var score;
score = 80; // 새로운 메모리 공간 확보하고 그곳에 할당값 80 저장
console.log(score); // 80
```

- 자바스크립트는 매니지드 언어. 가비지콜렉터가 메모리 해제.

## 네이밍 컨벤션

- 변수, 함수: 카멜 케이스
- 생성자 함수, 클래스 이름: 파스칼 케이스

# 5장: 표현식과 문

- 리터럴: 사람이 이해할 수 있는 문자 기호를 사용해 값을 생성하는 표기법
- 표현식: 값으로 평가될 수 있는 문
  - 표현식인 문 vs 표현식이 아닌 문 <= 변수에 할당해보면 알 수 있음
- 문: 프로그램을 구성하는 기본단위이자 최소 실행 단위
- 토큰: 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

# 6장: 데이터 타입

원시 타입 vs 객체 타입
데이터 타입에 따라 확보되는 메모리 크기는 엔진마다 다름
컴파일러나 인터프리터는 **심벌 테이블**이라고 부르는 자료구조를 통해 식별자를 키로 바인딩된 값의 메모리주소, 데이터 타입, 스코프를 관리
데이터 타입에 따라 -> 저장 메모리 공간 크기 결정 / 읽을 메모리 공간 크기 결정 / 값의 해석 결정 (A냐 65냐)

- 숫자 타입: 64비트 부동소수점 형식의 2진수 실수 (정수 타입 X)
  - Infinity, -Infinity, Nan 포함
- 문자열 타입: 작은 따옴표, 큰 따옴표, 벡틱으로 텍스트 감쌈
  - 문자열은 변경 불가능 한 값!
- 템플릿 리터럴: 벡틱을 사용해 표현, 줄바꿈 그대로 적용
  - 표현식 삽입 가능 ex. \`my name is ${name}\`
- 불리언
- undefined: 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값
  - var로 선언하면 암묵적으로 undefined로 초기화
    (자바스크립트에서는 변수를 선언하면 암묵적응로 정의가 이뤄진다)
- null: 변수에 값이 없다는 걸 의도적으로 명시 || 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null 반환하기도
- 심벌 타입: ES6 추가, 변경 불가능한 원시 타입의 값, 이름 충돌할 위험이 없는 유일무이한 심벌을 프로퍼티 키로 사용한다
- 객체: 자바스크립트를 이루고 있는 거의 모든 것

## 동적 타이핑

변수를 선언할 때 타입을 선언하지 않음! = 할당에 의해 타입이 결정(타입 추론)
변수의 타입을 언제든지 자유롭게 변경 가능!
변수는 타입을 가지지 않지만 값은 타입을 가진다

- 장점: 편리. 유연성 높음.
- 단점: 값 확인 전에 타입 확신 못함. 신뢰성 떨어짐.
  -> 변수 남발 금물, 변수 스코프 최대한 좁게, 전역변수 지양, 상수 사용하기, 변수 네이밍은 의미를 알 수 있게

# 7장: 연산자

- 증가/감소(++/--) 연산자: 피연산자의 값을 변경하는 부수 효과가 있음. 암묵적 할다 ㅇ이뤄짐.
  - 전위 연산자 vs 후위 연산자
- 문자열 연결 연산자: + 의 연산자 중 하나 이상이 문자열일 경우
  - 암묵적 타입변환/강제 타입 변환: 1+true 를 1+1로 해석
- 할당 연산자: 우항에 있는 연산ㄴ자를 좌항의 변수에 할당
  - =, +=, -= 따위의 것들
- 비교 연산자
  - == : 동등 비교, 암묵적 타입 변환으로 타입 일치 후 비교 (not good)
  - === : 일치 비교, 타입도 같고 값도 같을 때 true (good)
  - Nan === Nan 은 false, isNaN으로 NaN 판별해야
- 삼항 조건 연산자: `조건식 ? 조건식 true일 때 반환값 : 조건식 false일 때 반환값`
- 논리 연산자: ||, &&, !
  - 논리 부정 연산자(!): 언제나 불리언 반환
  - 논리합(||), 논리곱(&&) 연산자: 피연산자 중 어느 한쪽으로 평가
- 쉼표 연산자: 마지막 피연산자의 결과를 반환한다 (!!!)
  - ex) `x = 1, y = 2; // 2`
- 그룹 연산자( () ): 우선순위 높음
- typeof 연산자: 데이터 타입 반환
  - 근데 데이터 타입과 정확히 일치 안함;
  - `typeof null; // object` -> 널인지 확인하고 싶으면 일치 연산자(===) 사용
- 지수 연산자: ES7 도입. 이전엔 Math.pow 썼음. 할당 연산자 가능.
  - ex) `2 ** 2; // 4`, `num **= 2`
- 그 외 연산자: ?. ?? delete new instanceof in
- 연산자 우선순위랑 결합 순서 중 알아둬야할 것..?
