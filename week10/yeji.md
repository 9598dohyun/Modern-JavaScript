# 46장: 제너레이터와 async/await

## 제너레이터

코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 함수 

- 함수 제어권을 함수가 독점 X , 호출자에게 양도할 수 있음

- 함수 호출자와 함수 상태를 주고받을 수 있다 

- 반환 값은 제너레이터

- yield 키워드는 함수 실행 일시 중지 or 키워드 뒤 표현시그이 평과 결과를 제너레이터 함수 호출자에반환(예제 46-08)

- next 메서드를 호출하면 yield 표현식까지 실행되고 일시중지됨 -> 함수제어권이 호출자로 양도 

- next 메서드는 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환 

- value는 yield 된 값, done 은 제너레이터 함수가 끝까지 실행됐는지 나타내는 불리언 값

- next 메서드에는 인수를 전달할 수 있으며, yield 표현식을 할당받는 변수에 할당 (예제 46-09)

## async/await

async 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환한다. (인스턴스를 반환해야하는constructor는 async 함수가 될 수 없다.)

await 키워드는 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가resolve한 처리 결과를 반환한다. 

비동기 함수의 콜백 함수를 호출한 것은 비동기 함수가 아니기 떄문에 try…catch 문을 사용해 에러를캐치할 수 없다

async 함수 내에서 catch문으로 에러 처리 하지 않으면 -> 에러 reject하는 프로미스 반환



# 47장: 에러 처리

에러 객체 생성 & 발생: throw new Error();
에러는 호출자 방향으로 전파된다



# 48장: 모듈

모듈

- 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각

- 기능 기준으로 파일 단위로 분리, 모듈은 자신만의 파일 스코프가 있어야 

- 기본적으로 HTML script 태그로 로드된 자바스크립트 파일은 독자적인 모듈스코프를 갖지 않는다.

- ES6에서 모듈 기능 추가 
  ESM: ES6 모듈, script 태그에 type=“module” 어트리뷰트를 추가, 확장자 mjs

export 키워드

- 모듈 내 식별자 외부에 공개

- 선언문 앞에 사용(원하는 식별자를 하나의 객체로 구성하는 것도 가능) 

import 키워드

- import {a, b, c} from ‘./lib.mjs’

- Import * as lib from ‘./lib.mjs’

- Import {a as A, b as B, c as C} from ‘./lib.mjs’
