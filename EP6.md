## ep6. 데이터 타입

#### 목차

#### 1) 데이터 타입 
원시 타입 : number, string, boolean, undefined, null, symbol 
객체 타입 : 객체, 함수, 배열

* 숫자 1 vs 문자 "1"
사용용도와 목적이 다르며, 확보해야 할 메모리 공간 및 메모리에 저장되는 2진수도 다름

#### 2) 숫자 타입 
JS는 하나의 숫자 타입만 존재함(실수)
리터럴은 모두 2진수로 저장되기에, 정수만을 위한 타입이 없고, 모든 수를 실수로 처리함 
Infinity, -Infinity, not-a-number로 표현함 
```js
console.log(10/0); // Infinity
console.log(10/-0); // -Infinity
console.log(1*'String'); // NaN
```

#### 3) 문자열 타입
"", '', `` 으로 문자열 표시 
JS의 문자열은 원시 타입이며, 변경 불가능한 값임

#### 4) 템플릿 리터럴 ``
멀티라인 문자열, 태그트 템플릿, 표현식 삽입 등 편리한 문자열 처리 기능 제공 
* 멀티라인 문자열 
이스케이프 시퀀스를 사용하지 않아도 줄바꿈 가능, 공백 적용 
* 표현식 삽입 : 간단한 문자열 삽입
`${}`로 표현식을 감싸서 사용, 문자열로 타입의 강제 변환이 일어남 

#### 5) 불리언 타입

#### 6) undefined & null
개발자가 의도적으로 할당하기 위한 값이 아닌, 변수를 초기화할 때, garbage value를 업애기 위해 사용 
값이 없다는 것을 명시할 때는 null을 할딩

변수에 값을 명시하고자 할 때는 null 을 사용
변수에 값이 없음을 명시함(더 이상 값을 참조하지 않음을 표시)
함수가 유혀한 값을 반환할 수 없는 경우에는 명시적으로 null을 반환함 

#### 6) symbol 타입 
다른 값과 중복되지 않는 값, 객체의 유일한 프로퍼티 키를 만들기 위해 사용 

#### 7) 데이터 타입의 필요성
* 데이터 타입에 대한 메모리 공간의 확보와 참조(메모리 크기 결정)
* symbol table이라는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소/데이터 타입/스코프를 관리 
* 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정학 ㅣ위해 
* 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해 

#### 8) 동적 타이핑
재할당에 의해서 변수의 타입은 언제든지 동적으로 변화 가능하다. (JS, Python, php, ruby)
사전에 변수의 타입, 값 종류를 선언하는 정적 타입은 컴파일을 통해 타입 체크를 통해서 안정적인 코드를 구현(C, C++, JAVA)
var, const, let 키워드를 사용해 선언하고, 데이터 타입의 제약 없이 자유롭게 할당 가능 (타입 추론)
```js
// typeof를 통해 변수에 할당된 값의 데이터 타입을 반환
var foo;
console.log(typeof foo); // undefined
foo = 3;
console.log(foo); // number 
foo = {}; 
console.log(typeof foo); // object
```

* 동적 타입 언어의 단점 및 주의사항
변수가 변경가능하기에 복잡한 프로그램에서는 타입 확인이 어려움(높은 유연성, 낮은 신뢰성)
1) 변수는 꼭 필요한 경우에 한해 제한적으로 사용함(재할당에 의한 변경가능성 최소화)
2) 변수의 유효 범위는 최대한 좁게 만들어 부작용을 억제
3) 전역 변수는 어디서든 참조/변경가능하기에 최대한 사용하지 않도록 함
4) 변수보다는 상수를 사용해 값의 변경을 억제함
5) 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 짓기(협업과 생산성 향상)




