# 4장. 변수

## ✅ 변수란? 왜 필요한가?

### 🔆메모리에 데이터가 저장되는 형태

- 메모리는 메모리 셀의 집합체이다.
- 예제코드 - `var result = 10 + 20`
  ![메모리사진](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9daec16f-0ce7-42b8-a013-b147a735a12d%2FKakaoTalk_Photo_2023-01-28-15-30-18.jpeg?table=block&id=42472358-bc27-482a-8cd7-adb1808dbf7f&spaceId=28387fa4-40f9-4d3f-b9a8-d5794b37ada7&width=960&userId=d5e9cf37-3b9f-432c-b5db-dfa893d368d6&cache=v2)
- 10과 20은 메모리의 임의의 위치에 저장되고, CPU는 이 값을 읽어서 연산을 수행한다.
- 메모리에 저장되는 모든 값은 2진수로 저장된다. (사진은 편의상 10진수로 표시)
- 메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정된다.
  따라서 동일한 코드를 동일한 컴퓨터에서 실행해도 코드가 저장될 메모리 주소는 다름.

### 🔆변수란?

: 메모리 공간에 저장된 값을 **재사용** 할 수 있도록, **메모리 공간**에 이름을 붙인것
: 값의 메모리 위치를 가리키는 상징적인 이름이다.

: 변수를 사용하면 js엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

### 🔆변수가 필요한 이유

1. 재사용
   : 코드에서 `10+30;` 이라는 연산을 했다는 것은 이를 이용해 무언가를 하겠다는 의도가 있었을 것임.
   따라서 이 연산 결과를 저장해놓고, 다른 코드에서 “재사용” 할 수 있기 위해서

2. 안전한 접근을 위해서
   메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정된다.
   또한 동일한 코드를 동일한 컴퓨터에서 실행해도 코드가 저장될 메모리 주소는 다르다.
   때문에 메모리 주소를 통해 값에 직접 접근하려는 시도는 오류를 발생시킬 가능성이 높아 js는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
   따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없이, 변수를 통해 안전하게 값에 접근할 수 있다.

3. 가독성
   : 변수 값에 상징적인 이름을 붙여 변수에 저장된 값의 의미를 명확히 할 수 있음.→ 때문에 변수 이름만 보고도 이 값이 어떤 의미인지 알 수 있게끔 구체적으로 변수명을 지어야 함.

### 🔆 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

변수 이름이 곧 식별자다.

식별자(변수이름)는 값이 아니라 메모리 주소를 기억하고 있는 것이다.

따라서 식별자가 기억하고 있는 메모리 주소를 통해, 메모리 공간에 저장된 값에 접근할 수 있다.

### 🔆 변수이름은 어디에 등록되는지?

변수 이름을 비롯한 “모든 식별자”는 “실행 컨텍스트”에 등록된다.

- 실행 컨텍스트에 등록되는 것들
  1. 스코드
  2. this바인딩
  3. argument, 식별자 정보

## ✅ 변수 선언 / 값 할당 / 값 재할당

### 1. var - 런타임 이전에 변수 "선언 단계"와 "초기화 단계"가 한번에 진행됨.

```
var a;  // 1.변수 선언
a = undefined; // 2.값 할당(초기화) ← var의 경우 암묵적으로 이뤄짐
  ----------- 런타임 이후에 -------------
a = 10; // 3.할당
a = 20; // 4.재할당
```

- 단계1 - 변수 선언
  : 값을 저장하기 위한 메모리 “공간을 확보”하고, 변수 이름과 메모리 공간의 “주소를 연결”하는 것
- 단계2 - 초기화
  : 변수가 선언된 이후 최초로 값을 할당하는 것.
  : var로 선언한 변수는 undefined로 암묵적인 초기화가 자동으로 수행됨.
  ------------------------------------- 런타임 이후에 --------------------------------------
- 단계3 - 값 할당
  : 변수 할당문에 도달하면 비로소 값이 할당됨.
- 단계4 - 재할당
  : 재할당을 하면 이전 메모리 공간을 지우고 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 새로 저장하게 됨.
  이전 메모리 공간은 가비지 콜렉터에 의해 메모리에서 자동으로 해제됨.

※ 가비지 콜렉터
: 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는 메모리를 해제하는 기능.
: 개발자가 직접 관여할 수 없고 가비지 콜렉터에 의해 자동으로 실행되서, 언제 메모리에서 해제될 지는 예측할 수 없다.

### 2. let - 변수 "선언 단계"와 "초기화 단계"가 분리되어 진행된다.

: 런타임 이전에 변수 선언 단계만 먼저 진행되고, 초기화 단계는 변수 선언문에 도달해야 실행됨

```
let a;  // 1.변수 선언
  ----------- 런타임 이후에 -------------
a = 10; // 2.값 할당(초기화)
a = 20; // 3.재할당
```

### 3. const - let과 동일.

- 변수 선언과 동시에 초기화를 같이 해야 함.

```
const x = 1;
```

## ✅ 변수 선언의 실행 시점과 변수 호이스팅

### 🔆호이스팅이란?

변수,함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 현상

### 🔆var, let, const 키워드를 사용해 선언하는 변수는 모두 호이스팅이 된다.

- var는 호이스팅이 가능하지만, let,const는 호이스팅이 발생하지 않는 것처럼 동작한다.
  하지만 모두 변수 호이스팅이 되는 것임!
  (사실 변수 선언 뿐만 아니라 함수선언문 , class 키워드를 사용한 선언문 등 "모든 선언문"은 런타임 이전에서 먼저 실행되어 호이스팅 됨)
- 이유
  변수 선언은 런타임 이전에 준비됨.
  런타임 이전에 변수가 들어갈 공간이 미리 준비가 되기 때문에 호이스팅 발생하는 것 처럼 보인다.
  그러나 let,const는 tdz 때문에 참조에러가 발생하는 것뿐!

### 🔆var의 호이스팅

: var키워드로 선언한 변수는 런타임 이전에 암묵적으로 "변수 선언"과 "초기화"가 한번에 진행된다.때문에 런타임시 변수 선언문 이전에 변수를 참조할 수 있는 것임

```
console.log(score); // 2.런타임시 undefined 출력가능(호이스팅 가능)
var socore; // 1.런타임 이전에 "변수 선언"과 "초기화"가 이뤄짐(var는 선언과 동시에 undifined로 초기화됨.)
socore = 80;    // 3.런타임시 - "값 80이 할당"됨.
console.log(score);  // 4.80출력
```

### 🔆let의 호이스팅

- let키워드로 선언한 변수는 "변수 선언"과 "초기화" 단계가 분리되어 진행된다.초기화 단계는 런타임 이후에 실행된다.때문에 초기화 이전에 변수를 참조하려고 하면 참조 에러가 발생한다.
  때문에 let으로 선언한 변수는 변수 호이스팅이 발생하지 않는 것 처럼 보이는 것이다.
- TDZ(Temporal Dead Zone): 스코프 시작 지점부터 ~ 초기화 시작 지점까지는 변수를 참조할 수 없는 구간

```
console.log(foo);
// 2.런타임시 이전에 변수가 들어갈 공간이 준비되어 있기 때문에 호이스팅 발생함.
// 그러나 tdz 때문에 참조에러 발생하는 것임

let foo; // 1.런타임 이전에 변수 선언만 함
console.log(foo); // 3. undefined - 런타임시 변수 선언문에서 초기화가 실행됨.

foo = 1; // 4. 값 할당
console.log(foo); // 1 5.값이 참조됨.
```

### 🔆const의 호이스팅

- let과 비슷
- 변수 선언과 동시에 초기화를 같이 해야 함. (변수 선언은 런타임 이전에 되고, 초기화는 런타임때 되는 것임.)

```
console.log(foo); // ReferrenceError // 2.호이스팅 됨. 하지만 참조에러 발생

const foo = 1; // 1.런타임 이전에 변수 선언만 됨 // 3.초기화 됨

console.log(foo); // 4.값 참조 가능
```

> < hoisting 요약정리 >

1. var, let, const는 모두 호이스팅이 가능하다.
2. 그러나 let, const는 호이스팅이 안되는 것 처럼 보인다.(사실 호이스팅이 가능하다. 때문에 "참조"에러가 나는 것임)
3. 그 이유는 let, const의 변수 선언은 런타임 이전에 되기때문에 호이스팅이 가능한 것이지만
   초기화는 런타임시 되는데, 이때 TDZ라는 "스코프 시작~초기화" 단계 동안은 변수를 참조할 수 없는 구간이 있기 때문에 되지 않는 것 처럼 보이는 것이다.
   >

## ✅ 식별자 / 식별자 네이밍 규칙

1. 식별자 이름은 데이터를 쉽게 식별할 수 있기위해 서술적이어야 함.
2. camelCase방식: 각 단어의 앞글자는 대문자로 함 ex) topMenuBtn , numCount
3. 네이밍 규칙

- 절대 안되는 규칙 (3개)

1. 예약어 : ex) await, class, for (x)
2. 공백 : ex) top menu(x)
3. $,\_ 제외한 특수문자 : ex) topMenu!(x) top-Menu(x) $topMenu(o)

- 첫글자에만 안되는 규칙 (1개)

1. 숫자 : ex) 2topMenu(x) topMenu2(o)
