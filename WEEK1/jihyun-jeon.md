# 4장. 변수

## ✅ 변수란? 왜 필요한가?

### 🔆변수란?

: 메모리 공간에 저장된 값을 <b>재사용</b> 할 수 있도록, <b>메모리 공간</b>에 이름을 붙인것<Br/>
: 값의 메모리 위치를 가리키는 상징적인 이름이다.

: 변수를 사용하면 js엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.
<Br/><Br/>

### 🔆변수가 필요한 이유

1. 재사용<Br/>
   어떠한 연산의 결과를 저장해놓고, 다른 코드에서 “재사용” 할 수 있기 위해서

2. 안전한 접근을 위해서<Br/>
   메모리 주소를 통해 값에 직접 접근하려는 시도는 오류를 발생시킬 가능성이 높아 js는 개발자의 직접적인 메모리 제어를 허용하지 않는다.<Br/>
   따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없이, 변수를 통해 안전하게 값에 접근할 수 있다.

3. 가독성<Br/>
   변수 값에 상징적인 이름을 붙여 변수에 저장된 값의 의미를 명확히 할 수 있음.→ 때문에 변수 이름만 보고도 이 값이 어떤 의미인지 알 수 있게끔 구체적으로 변수명을 지어야 함.
   <Br/><Br/>

<Br/><Br/>

## ✅ 변수 선언, 값 할당, 값 재할당

### 🔆 var - 런타임 이전에 변수 "선언 단계"와 "초기화 단계"가 한번에 진행됨.

```javascript
var a;  // 1.변수 선언
a = undefined; // 2.값 할당(초기화) ← var의 경우 암묵적으로 이뤄짐
  ----------- 런타임 이후에 -------------
a = 10; // 3.할당
a = 20; // 4.재할당
```

- 단계1 - 변수 선언<br/>
  : 값을 저장하기 위한 메모리 “공간을 확보”하고, 변수 이름과 메모리 공간의 “주소를 연결”하는 것
  <br/><br/>
- 단계2 - 초기화<br/>
  : 변수가 선언된 이후 최초로 값을 할당하는 것.<br/>
  : var로 선언한 변수는 undefined로 암묵적인 초기화가 자동으로 수행됨.
  <br/><br/>
  --------------------------------- 런타임 이후에 -----------------------------------
- 단계3 - 값 할당<br/>
  : 변수 할당문에 도달하면 비로소 값이 할당됨.
  <br/><br/>
- 단계4 - 재할당<br/>
  : 재할당을 하면 이전 메모리 공간을 지우고 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 새로 저장하게 됨.<br/>
  이전 메모리 공간은 가비지 콜렉터에 의해 메모리에서 자동으로 해제됨.

<br/>

## ✅ 변수 호이스팅

### 🔆호이스팅이란?

- 변수,함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 현상
- var, let, const 키워드를 사용해 선언하는 변수 뿐만 아니라 <br/>
  함수선언문 , class 키워드를 사용한 선언문 등 "모든 선언문"은 모두 호이스팅 됨
  <br/><br/>

### 🔆호이스팅이 가능한 이유

모든 선언문은 런타임 이전에 먼저 실행됨.<br/>
때문에 런타임 이전에 변수가 들어갈 공간이 미리 준비가 되기 때문에 호이스팅이 가능한 것임.

<br/><br/>

## ✅ 식별자 네이밍 규칙

1. 식별자 이름은 데이터를 쉽게 식별할 수 있기위해 서술적이어야 함.

2. camelCase방식: 각 단어의 앞글자는 대문자로 함 ex) topMenuBtn , numCount

3. 네이밍 규칙

- 절대 안되는 규칙 (3개)

      1. 예약어 : ex) await, class, for (x)
      2. 공백 : ex) top menu(x)
      3. $,\_ 제외한 특수문자 : ex) topMenu!(x) top-Menu(x) $topMenu(o)

  <br/>

- 첫글자에만 안되는 규칙 (1개)

  1. 숫자 : ex) 2topMenu(x) topMenu2(o)

---

<br/>

# 5장. 표현식과 문

### ✅ 값

- 표현식이 평가되어 생성된 결과 <br/>
- 예) `var sum = 10 + 20` ← 10+20이 평가되어 생성된 값인 30이 변수에 할당된다.

 <br/>

### ✅ 리터럴

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법 <br/>
- 자바스크립트 엔진이 리터럴을 평가해 값을 생성한다.<br/>
- 예제

  ex) 0x000000F2 → 리터럴로 표시하면 3이 됨. <br/>
  ex) 3 → 숫자 리터럴 3을 js엔진이 평가해 숫자 값 3을 생성하는 것임. <br/>
  ex) 숫자 리터럴(3), 문자열 리터럴("hello"), 불리언 리터럴(true), null리터럴, 객체 배열 리터럴...

 <br/>

### ✅ 표현식

- "값"으로 평가될 수 있는 문<br/>

- 예제<br/>

  1. 리터럴 표현식 : 10, "hello" , true, null

  2. 연산자 표현식 : 10+20 , sum !== 10 , sum = 10<br/>
     (숫자 리터럴은 js엔진에 의해 평가되어 값을 생성하므로 리터럴(10)은 그 자체가 표현식이다.)

  3. 함수,메서드 호출 표현식 (이미 함수 선언이 존재한다는 가정)<br/>
     : square(), persom.getName()<br/>

  4. 식별자 표현식(이미 선언문이 존재한다는 가정) <br/>
     : sum , person.name , arr[1]

 <br/>

### ✅ 문

- 프로그램을 구성하는 기본 단위이자 최소 실행 단위.
- 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 바로 프로그래밍이다.
- 문을 끝낼 때는 세미콜론을 붙여야 한다. <br/>
  (단, 중괄호로 묶은 코드블록은 그 자체로 종결성을 갖기 때문에 세미콜론 붙일 필요 없음)

<br/>

### ✅ 문과 식의 구별법

- 표현식인 문: 값으로 평가될 수 있는 문
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문

  <br/>

📌 "변수에 할당" 할 수 있으면 식이고, 아니면 문임

```javascript
1. 문(statement)
 if(){} // if문을 변수에 담을 수 없음.
 function(){} // 이 자체는 함수 선언문임.

2. 식(expression)
  var a = 100; // 100은 숫자 리터럴이며 이 값을 변수에 할당할 수 있음
  var b = function(){} // 함수 선언문을 값으로 활용하여 변수에 할당 가능
```

<br/>

📌 함수 표현문과 함수 표현식<br/>
: 함수는 크게 1) 함수 선언문과 2) 함수 표현식으로 만들 수 있다.

```javascript
// 1) 함수 선언문 (statement) : 값으로 평가될 수 없음
function name() {}

// 2) 함수 표현식 expression(식) : 함수선언을 "값 처럼" 활용해서 함수를 만드는 방식.
// 함수선언문(이벤트 핸들러 함수)을 값처럼 활용하고 있음. 따라서 "함수표현식"임
myBtn.addEventListener("click", function () {
  consolg.log("gg");
});
```

---

<br/>

# 06장

## ✅ 데이터 타입 분류

### < primitive type >

1. 숫자형 타입(numbr)

- 정수,실수,음의 정수 등 모든 수를 다 “실수”로 처리하며, 모두 “2진수”형태로 저장되고, 값 참조시 “10진수”로 해석한다.
- 주의 : Infinity, -Infinity, NaN ← 모두 number타입임!

<br/>

2. 문자열 타입 (string)

- 템플릿 리터럴 : 줄바꿈, 공백이 있는 그대로 적용된다.
  ```jsx
  var template = `Template literal`;
  console.log(template); // Template literal
  ```

<br/>

3. 불리언 타입(boolean)

<br/>

4. undefined

- 개발자가 의도적으로 할당한 값이 아니라, var키워드로 선언한 변수에 초기화를 할 때 사용하는 값이다.

<br/>

5. null

- 개발자가 의도적으로 변수에 값이 없다는 것을 명시할 때 사용.
  ```jsx
  var foo = "Lee";
  foo = null; // 변수에 null을 할당함으로서, 변수가 이전에 참조하던 값에 대한 참조를 명시적으로 제거하게 되는 것임.
  ```
- `typeof null`은 “object”이다. <br/>
  : js의 버그이다.<br/>
  : 때문에 값이 null 타입인지 확인할 때는 typeof보단, === 을 사용하자.

<br/>

6. 심벌 타입(symbol)

- 변경 불가능한 원시 타입의 값이다.
- 다른 값과 중복되지 않는 유일무이한 값임.
- 따라서 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용됨.

<br/>

### < reference type >

1.object 2.array 3.function 등

<br/>

## ✅ 데이터 타입을 구별하는 이유

1. 값을 저장할 때 확보해야 할 "메모리 공간의 크기"를 결정하기 위해
2. 메모리에서 읽어 들인 2진수를 어떤 데이터 타입으로 "해석"할지 결정하기 위해.

<br/>

## ✅ 변수 사용시 주의점

1. 변수는 꼭 필요한 경우만 제한적으로 사용한다. 변수 개수가 많을수록 타입을 잘못 예측해 오류 발생할 수도 있고 오류 발생 확률도 높아지기 때문

2. 변수의 유효범위는 최대한 좁게 만든다. 스코프를 제한하여 오류 발생을 줄인다.
3. 변수보다는 상수를 사용한다.
4. 변수명을 명확하게 짓는다.

---

<br/>

# 07장

## ✅  산술 연산자

### 1. 원칙

- 대부분의 산술 연산자는 오직 숫자형의 피연산자만 다루고,
- 피연산자가 숫자형이 아닌 경우에 그 타입을 `"숫자형"`으로 바꾼다.<br/>
  [이항 산술 연산자]

  ```jsx
  // 예제1
  alert(1 + true); // 2, true는 1로 타입 변환됨
  console.log(typeof (1 + true)); // number

  // 예제2
  alert(1 + null); // 1, null은 0으로 타입 변환됨
  console.log(typeof (1 + null)); // number

  // 예제3
  alert(6 - "2"); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
  console.log(typeof (6 - "2")); //  number

  // 예제4
  alert("6" / "2"); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.
  console.log(typeof ("6" / "2")); // number
  ```

  [단항 산술 연산자]

  - “숫자 타입이 아닌 피연산자”에 “(+,-)단항연산자”를 쓰면, `"숫자형"`으로 바뀜.
  - "+" 예제

  ```jsx
  let num = "1234";
  console.log(+num); // 1234 (문자열을 숫자로 타입 변환한다)
  console.log(num); // '1234' (원본은 그대로, 부수 효과는 없다.)

  let bool = false;
  console.log(+bool); // 0 (불린타입을 숫자형으로 타입 변환한다)
  console.log(bool); // false (원본은 그대로, 부수 효과는 없다.)
  ```

  - "-" 예제

  ```jsx
  let num = "1234";
  console.log(-num); // -1234 (문자열을 숫자로 타입 변환한다)
  console.log(num); // '1234' (원본은 그대로, 부수 효과는 없다.)

  let bool = true;
  console.log(-bool); // -1 (불린타입을 숫자형으로 타입 변환한다)
  console.log(bool); // false (원본은 그대로, 부수 효과는 없다.)
  ```

<br/>

### 2.예외

그러나 덧셈 연산자(+)는 좀 특이함.

- Number형과 String을 더하면 항상 `"문자열"`로 변환됨.

```jsx
// 예제1
alert(2 + 2 + "1"); // '221'이 아니라 '41'이 출력됩니다.("1"를 그대로 문자로 읽음)
console.log(typeof (2 + 2 + "1")); // string
```

<br/>

### 🔆  증감 연산자

- 증가/감소 연산자는 "변수에만" 쓸 수 있음. 5++와 같이 값에 바로 사용하려고 하면 에러가 발생.
- ++ , — 연산자는 위치에 의미가 있다.

```jsx
let x = 5;
let result;

result = x++; // 선할당, 후증가 // x를 result에 할당한 후, x를 +1 증가시킨다.
console.log(result, x); // 5, 6

result = ++x; // 선증가, 후할당 // x를 +1 증가시킨 후, x를 result에 할당한다.
console.log(result, x); // 7 , 7

result = x--; // 선할당, 후감소 // x를 result에 할당한 후, x를 -1 감소시킨다.
console.log(result, x); // 7, 6

result = --x; // 선감소, 후할당 // x를 -1 감소시킨 후, x를 result에 할당한다.
console.log(result, x); // 5, 5
```

<br/>

## ✅  비교 연산자

### 🔆 == 와 === 의 차이

==

- 먼저 암묵적으로 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다.
- 따라서 타입까지 같은진 판단할 수 없다.

===

- 타입도 같고, 값도 같은지 판단한다.

```jsx
0 == ""; // true
0 == "0"; // true
0 === ""; // false
0 == "0"; // false
```

<br/>

### 🔆 주의

- NaN은 자신과 일치하지 않는 유일한 값이다.
- 따라서 숫자가 NaN인지 파악하려면 isNaN을 사용해야 한다.

```jsx
NaN === NaN; // false
isNaN(NaN); // true
```

<br/>

## ✅  논리 부정 연산자

- 언제나 불리언 값을 반환한다.
- 피연산자가 불리언 값이 아니라면, 불리언 타입으로 암묵적으로 타입을 변환한다.

```jsx
!0; // true (0은 falsy value이므로 반전되어 true가 된다.)
!"Hello"; // false (문자열은 trusy value이므로 반전되어 false가 된다.)
```
