#  27장. 배열
## 배열이란

✔️ 자료구조에서 말하는 배열

- 동일한 크기의 메모리 공간이, 빈틈없이 연속적으로 나열된 자료구조 (밀집배열)
- 장: 인덱스를 통해 단 한 번의 연산으로 요소에 접근 가능 (효율적, 고속으로 동작함)
- 단 : 요소를 삭제나 중간의 삽입을 한다면 다른 요소들을 한칸씩 다 이동시켜야한다.

✔️ 자바스크립트에서 말하는 배열

- 메모리 공간 크기가 다 같지 않아도 되고,  요소 일부가 비워있는 둥 연속적으로 이어져 있지 않을 수도 있음 (희소배열)
ex) `const arr =[ , 2, , 4]` ← 이런식으로 요소가 비워저있는 희소배열은 만들지 않도록 주의!
- js에서의 배열은  일반적인 의미의 배열이 아니다.  배열 동작을 흉내낸 특수한 “객체”이다.
- 배열은 “객체” 타입임 : 인덱스가 프로퍼티 키, 배열 요소가 프로퍼티 값인 것임.
`typeof [] // object`

✔️ 두 배열 비교

자료구조에서 말하는 배열 : 인덱스로 요소에 빠르게 접근 가능 / 특정 요소를 검색, 요소를 삽입 또는 삭제 할 경우 효율↓

자바스크립트에서의 배열 : 인덱스로 요소에 접근할 때 성능↓ / 특정 요소를 검색, 요소를 삽입 또는 삭제 할 경우 성능↑ (일반적인 의미의 배열보다 빠름)

## Array 생성자 함수

```
<인수가 없는 경우> : 빈 배열 리터럴 생성
new Array(); // [] 

<인수가 1개, 인수가 숫자> : 인수만큼 배열 length가 생김. 요소는 존재하지 않음
new Array(3); // [undefined,undefined,undefined] 

<인수가 2개이상> : 해당 인수를 요소로 갖는 배열 생성
new Array(1,2,3); // [1,2,3]

<인수가 1개, 인수가 숫자x> : 해당 인수를 요소로 갖는 배열 생성
new Array({}); // [{}]

<new 없이> Array생성자 함수는 new 없이 호출해도 생성자 함수로 동장
Array(1,2,3); // [1,2,3] 
Array(3); // [undefined,undefined,undefined]

<인수가 1개, 인수가 숫자> 이더라도 해당 인수를 요소로 갖는 배열 생성 
Array.of(3); // [3]
```

Array.of

- es6에서 도입
- 전달된 이수를 요소로 갖는 “배열” 생성함.
- `Array.of(1,2,"a"); // [1,2,"a"]`

## 고차함수

※ [참고 포스팅](https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-22-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98Higher-Order-Function-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

- 고차함수란? : 함수를 인수로 전달받거나, 함수를 반환하는 함수
- 고차함수를 쓰면 외부 상태의 변경이나 데이터 가변을 피하여 불변성을 지향하는 함수형 프로그래밍 구현 가능하다.
    
    : 조건문이나 반복문을 사용하면 로직의 흐름을 어렵게 만들어 가독성을 해침
    
    : 변수를 사용하여 상태 변경하면 누군가에 의해 변경될 수 있어 오류 위험 있음
    
    → 때문에 고차함수를 사용한 “순수 함수”를 사용하면 부수 효과를 억제하여 오류를 줄일 수 있다.
    

```jsx
// <고차함수 사용하지 않는다면>
const arr1 = [1, 2, 3];
const arr2 = []; // 이 변수에 담길 값을 한번에 예측할 수 없고

for(let i=0; i<arr1.length; i++) {
  arr2.push(arr1[i] * 2); // 반복문을 사용해서 코드 흐름이 깨짐
}

// <고차함수 사용하면>
const arr1 = [1, 2, 3];

const arr2 = arr1.map((item)=> {
  return item * 2;
});

console.log(arr2); // prints [2, 4, 6]
```

## 메서드 요약(헷갈리는것 위주로)

- Array.prototype.pop() : 마지막 요소를 제거하고, “제거한 요소”를 반환
- Array.prototype.shift() : 첫번째 요소를 제거하고, “제거한 요소”를 반환
- Array.prototype.unshift() : 첫번째 요소를 추가하고, 변경된 배열 “길이”를 반환

```jsx
[1,[2, [3, [4]]]].flat(); // [1,2, [3, [4]]] // 기본 인수값은 1이다.
[1,[2, [3, [4]]]].flat(1); // 동일

[1,[2, [3, [4]]]].flat(2); // [1,2,3,[4]] // 2단계 깊이까지 평탄화
[1,[2, [3, [4]]]].flat().flat(); // 동일

[1,[2, [3, [4]]]].flat(Infinity); // [1,2,3,4] // 모든 깊이를 평탄화
```

- Array.prototype.flatMap() :es10에서 도입
: map메서드를 통해 생성된 새로운 배열을 flat메서드로 평탄화 하는 동작과 같음.
: 1단계만 평탄화 가능, 때문에 평탄화 깊이를 지정해야 하면 flat 사용하도록