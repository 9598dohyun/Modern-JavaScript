# 11장: 원시 값과 객체의 비교
- 원시 값: 변경 불가능한 값, 변수에 실제 값 저장
- 객체 값: 변경 가능한 값, 참조 값 저장 
- 값에 의한 전달: 원시 값을 갖는 변수를 다른 변수에 할당하면, 원시 값이 복사되어 전달
- 참조에 의한 전달: 객체를 가리키는 변수를 다른 변수에 할당하면, 참조 값이 복사되어 전달

## 원시값
- 불변성: 원시 값을 재할당하면 새로운 메모리 공간 확보 -> 재할당한 값 저장 -> 변수가 참조하던 메모리 공간 주소 변경

### 문자열과 불변성
원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야 
ECMAScript 사양에는 문자열 타입(2바이트) 숫자타입(8바이트) 이외 원시 타입 규정X
- 문자열
 - 1 개 문자는 2바이트 메모리 공간에 저장
 - 원시 타입이므로 변경 불가능 
 - 유사 배열 객체이면서 이터러블해 각 문자에 접근 가능(index 접근, for문, length)

### 값에 의한 전달 
`새 변수 = 원래 변수`
별개의 메모리 공간에 값이 저장되므로, 할당 이후 원래 변수 값을 바꿔도 새 변수 값에는 영향X
> 값에 의한 전달은 오해가 있을 수 있음. 변수에는 값이 아니라 메모리 주소가 전달되기 때문. 

평가 방식
1. 새로운 값 생성해 메모리 주소 전달 -> 할당 시점에 두 변수의 메모리 주소 다름 
2. 기존 변수의 메모리 주소 그대로 전달했다가, 할당이 이뤄졌을 때 비로소 재할당된 값 저장 -> 할당 시점에 두 변수의 메모리 주소 같음 

## 객체
프로퍼티 개수 정해져 있지 않고 동적 추가삭제 가능 -> 확보할 메모리 크기 사전에 정해둘 수 없음 

> **자바스크립트 객체 관리 방식**
> 자바스크립트 객체는 프로프티 키를 인덱스로 사용하는 해시테이블이라고 생각할 수 있다. 
> 자바, C++ 과 달리 클래스 없이도 객체 생성 가능하고 동적으로 프로퍼티와 메서드 추가 가능 -> 더 비효율적
> -> 히든 클래스: 동적 탐색 대신 프로퍼티에 접근하는 방법. 성능 향상.

### 변경 가능한 값 
객체를 할당한 변수를 참조하면, 메모리에 저장된 참조값으로 실제 객체에 접근 
프로퍼티 값을 갱신하거나 동적으로 생성하면, 기존 객체가 저장된 메모리에서 변경한다
왜? 객체를 변경할 때마다 복사하면 비용이 많이 든다. 객체 크기는 제각각이고 크기가 매우 클수도 있어서.
단점! 여러 개의 식별자가 하나의 객체를 공유할 수도 있음

### 얕은 복사와 깊은 복사 
얕은 복사: 한 단계까지만 복사
깊은 복사: 객체에 중첩돼있는 객체도 복사 
```
// 객체 변수 c1 = o라고 할 때

// 얕은 복사
c1 === o // false
c1.x === o.x // true

// 깊은 복사
c1 === o // false
c1.x === o.x // false
```
> === 일치 비교 연산자는 객체 할당 변수는 참조 값을 비교하고, 원시 값 할당 변수는 원시값을 비교한다.

### 참조에 의한 전달 
원본과 사본의 메모리 주소는 다르지만, 값이 동일한 참조값 -> 두 개의 식별자가 하나의 객체를 공유 
원본/사본 중 어느 한쪽에서 객체 변경 -> 다른 쪽에도 영향을 줌 

## 자바스크립트에는 사실 값에 의한 전달만 존재한다!
값에 의한 전달이나 참조에 의한 전달은 식별자가 기억하는 **메모리 공간에 저장돼 있는 값을 전달**하는 것 동일
다만 식별자가 기억하는 메모리 공간이 원시값, 참조 값의 차이만 있음
그러나 편의상 원시 값을 전달하면 '값에 의한 전달', 참조 값을 전달하면 '참조에 의한 전달'이라고 하자




