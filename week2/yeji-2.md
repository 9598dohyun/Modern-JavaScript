# 11장: 원시 값과 객체의 비교

- 원시 값: 변경 불가능한 값, 변수에 실제 값 저장
- 객체 값: 변경 가능한 값, 참조 값 저장
- 값에 의한 전달: 원시 값을 갖는 변수를 다른 변수에 할당하면, 원시 값이 복사되어 전달
- 참조에 의한 전달: 객체를 가리키는 변수를 다른 변수에 할당하면, 참조 값이 복사되어 전달

## 원시값

- 불변성: 원시 값을 재할당하면 새로운 메모리 공간 확보 -> 재할당한 값 저장 -> 변수가 참조하던 메모리 공간 주소 변경

### 문자열과 불변성

원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야
ECMAScript 사양에는 문자열 타입(2바이트) 숫자타입(8바이트) 이외 원시 타입 규정X

- 문자열
- 1 개 문자는 2바이트 메모리 공간에 저장
- 원시 타입이므로 변경 불가능
- 유사 배열 객체이면서 이터러블해 각 문자에 접근 가능(index 접근, for문, length)

### 값에 의한 전달

`새 변수 = 원래 변수`
별개의 메모리 공간에 값이 저장되므로, 할당 이후 원래 변수 값을 바꿔도 새 변수 값에는 영향X
> 값에 의한 전달은 오해가 있을 수 있음. 변수에는 값이 아니라 메모리 주소가 전달되기 때문.

평가 방식

1. 새로운 값 생성해 메모리 주소 전달 -> 할당 시점에 두 변수의 메모리 주소 다름
2. 기존 변수의 메모리 주소 그대로 전달했다가, 할당이 이뤄졌을 때 비로소 재할당된 값 저장 -> 할당 시점에 두 변수의 메모리 주소 같음

## 객체

프로퍼티 개수 정해져 있지 않고 동적 추가삭제 가능 -> 확보할 메모리 크기 사전에 정해둘 수 없음

> **자바스크립트 객체 관리 방식**
> 자바스크립트 객체는 프로프티 키를 인덱스로 사용하는 해시테이블이라고 생각할 수 있다.
> 자바, C++ 과 달리 클래스 없이도 객체 생성 가능하고 동적으로 프로퍼티와 메서드 추가 가능 -> 더 비효율적
> -> 히든 클래스: 동적 탐색 대신 프로퍼티에 접근하는 방법. 성능 향상.

### 변경 가능한 값

객체를 할당한 변수를 참조하면, 메모리에 저장된 참조값으로 실제 객체에 접근
프로퍼티 값을 갱신하거나 동적으로 생성하면, 기존 객체가 저장된 메모리에서 변경한다
왜? 객체를 변경할 때마다 복사하면 비용이 많이 든다. 객체 크기는 제각각이고 크기가 매우 클수도 있어서.
단점! 여러 개의 식별자가 하나의 객체를 공유할 수도 있음

### 얕은 복사와 깊은 복사

얕은 복사: 한 단계까지만 복사
깊은 복사: 객체에 중첩돼있는 객체도 복사

```
// 객체 변수 c1 = o라고 할 때

// 얕은 복사
c1 === o // false
c1.x === o.x // true

// 깊은 복사
c1 === o // false
c1.x === o.x // false
```

> === 일치 비교 연산자는 객체 할당 변수는 참조 값을 비교하고, 원시 값 할당 변수는 원시값을 비교한다.

### 참조에 의한 전달

원본과 사본의 메모리 주소는 다르지만, 값이 동일한 참조값 -> 두 개의 식별자가 하나의 객체를 공유
원본/사본 중 어느 한쪽에서 객체 변경 -> 다른 쪽에도 영향을 줌

## 자바스크립트에는 사실 값에 의한 전달만 존재한다

값에 의한 전달이나 참조에 의한 전달은 식별자가 기억하는 **메모리 공간에 저장돼 있는 값을 전달**하는 것 동일
다만 식별자가 기억하는 메모리 공간이 원시값, 참조 값의 차이만 있음
그러나 편의상 원시 값을 전달하면 '값에 의한 전달', 참조 값을 전달하면 '참조에 의한 전달'이라고 하자

# 12장: 함수

## 함수 리터럴

자바스크립트의 함수는 객체 타입의 값
function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성
함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. (외부에서 이름으로 호출 불가)

```
(function bar() {console.log('bar')};); // 피연산자는 함수 리터럴 표현식 
bar(); // ReferenceError bar is not defined // 함수 리터럴에서 이름은 외부에서 호출 불가

```

## 함수 정의
> 변수 선언과 함수 정의(158p) 의미?

```
function add(x,y) {
    return x + y;
}
console.log(add);

/*
출력 결과
ƒ add(x,y) {
    return x + y;
}
*/
```

### 함수 선언문

함수 선언문은 표현식이 아닌 문이다 -> 변수에 할당할 수 없다  
함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일  
```
function foo() {
    console.log('foo');
}
foo(); // 식별자가 없어도 자바스크립트 엔진이 암묵적으로 식별자 생성해 호출 가능

```

기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 수 있음  

기명 함수 리터럴  

- 단독으로 사용(피연산자 X) -> 함수 선언문으로 해석(호출 가능)
- 값으로 평가되는 문맥(변수에 할당 or 피연산자) -> 함수 표현식으로 해석(호출 불가)

함수는 함수 이름으로 호출 X, 함수 객체를 가리키는 식별자로 호출 O
```
const add = function add(x,y) {
    return x + y;
}
console.log(add(2, 5)); // 함수 이름이 아닌 식별자를 호출해 7
```

## 함수 표현식  
자바스크립트의 함수는 값의 성질을 갖는 객체인 **일급 객체**
함수 표현식 = **함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식** 
함수 선언문은 **표현식이 아닌 문** 이고 함수 표현식은 **표현식인 문**이다.

```
// 바로 이런 형식! 
const add = function (x, y){
    return x + y;
}
```

```
const add = function foo(x,y) {
    return x + y;
}
console.log(foo(2, 5)); // ReferenceError, 기명 함수 리터럴이 값으로 평가되면 함수 표현식이라 호출 불가
``` 

> 함수 리터럴, 함수 선언문, 함수 표현식의 차이?
> 함수 리터럴은 함수를 표현하는 방식
> 함수 선언문은 함수에 식별자가 붙어있어 호출 가능한 함수
> 함수 표현식은 어떤 변수에 할당되는 함수 리터럴

## 함수 생성 시점과 함수 호이스팅

**함수 선언문**으로 정의한 함수, 함수 선언문 이전에 호출 O  

- 모든 선언문이 그렇듯, 런타임 이전에 먼저 실행  
- 함수 이름과 동일한 식별자를 암묵적으로 생성하고 함수 객체 할당
- **호이스팅**: 함수 선언문이 코드 선두로 끌어 올려진 것 처럼 동작하는 JS 고유 특징
- 변수 호이스팅과의 차이점: 변수 선언문에서 변수는 undefined로 초기화되고, 함수 선언문은 함수 객체로 초기화 

**함수 표현식**으로 정의한 함수, 함수 표현식 이전에 호출 X  

- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 것
- 런타임 이전에 변수는 undefined로 초기화됨
- 할당문이 실행되는 시점(런타임)에 함수 객체가 됨 
- 변수 호이스팅이 되는 것!!!  
 
함수 선언문 대신 **함수 표현식**을 사용하자. 
함수 호이스팅은 함수 호출 전 함수를 선언해야한다는 당연한 규칙을 무시하니까!  

## Function 생성자 함수

```
var add = new Function('x', 'y', 'return x + y');
console.log(add(2, 5)); // 7
```
이렇게 생겼는데, 일반적이지 않고 바람직하지 않는 방법.  
클로저를 생성하지 않는 등 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하니까.

## 화살표 함수

```
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
표현과 내부동작 모두 간략화 됨

- 화살표 함수는 생성자 함수로 사용 X
- 기존 함수와 this 바인딩 방식이 다름
- prototype 프로퍼티가 없음
- arguments 객체를 생성하지 않음 

