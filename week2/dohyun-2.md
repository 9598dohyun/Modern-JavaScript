## 원시값과 객체의 비교

1. 원시값: 변경불가능한값
2. 객체값: 변경가능한 값

```
원시값의 경우 변수의 값을 변경하기 위해 원시값을 재할당하면 새로운 메모리공간이 추가되고 
변수가 참조하던 주소를 변경한다. 변경하기전의 메모리공간은 GC가 관리한다.
```

자바의 경우 문자열은 '**string**' 객체로 처리하지만 자바스크립트에서의 문자열은 원시타입이며 0개이상의 문자로 이루어진 집합을 의미한다.
또 string은 마치 배열처럼 Index('[]')로 프로퍼티값에 접근할수 있고 length프로퍼티를 가진다
<br/>

```(for문(반복문)으로도 순회를 할수있다.)```

- 값에 의한 전달

```js
var score = 80;
var copy  = score;

var score = 100;

console.log( score,copy); // 100,80
```
스코어와 카피의 값은 서로 다른 메모리공간에 저장된 별개의 값이다.!

- 값에 의한 전달은 갑이 전달되는 것이 아닌 메모리 주소가 전달되는 것이다.!!!!

## 객체

- 프로퍼티의 개수 정해져 있지 않고 동적으로 추가되고 삭제될수있다.

자바,C++의 객체생성방식은 사전정의된 클래스를 기반으로 객체를 생성하고 생성된 이후에는 프로퍼티와 메서드를 수정할수 없지만,
자바스크립트는 클래스없이 객체를 생성할 수 있으며, 프로퍼티와 메서드를 수정할 수 있다.

객체를 생성및 관리하는 방식은 원시값처럼 크기가 일정하지 않아 메모리의 효율이 좋지않고, 나빠진다.

그래서 효율을 증가시키기위헤 객체는 변경가능하게 설계되었다.

이에따른 부작용으로는 여려개의 식별자가 하나의 객체를 공유할수 있다라는 점이다.
(관리가 어렵다..)

1. 얕은 복사
   - 한단계가지만 복사
2. 깊은 복사 
   - 객체에 중첩되어있는 모든 객체를 복사
```js
const  v =1;
// 깊은 복사
//원시값을 할당한 변수를 다른변수에 할당하는 것
c1 === v // false
console.log(c1 === v); //true

const o = {x:1};
// 얕은 복사
// 객체를 할당한 변수를 다른변수에 할당하는것
c2 === o // false
console.log(c2 === o ) // true
```

얕은 복사는 참조에 의한 전달이라고 볼수 있는데, 이것은 둑의 식별자가 하나의 객체를 공유하는것을 의미한다.



