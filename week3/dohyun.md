# 13장: 스코프

- 스코프는 유효범위를 뜻한다.
  - 선언된 위치에 따라 전역/지역으로 나뉘게 된다. (스코프는 식별자가 유효한 범위를 뜻한다.)

1. 전역
   - 코드의 가장 바깥영역에서 선언한 변수
2. 지역
   - 함수 내에서 선언된 변수(함수내에서 식별이 가능하다.)

스코프란 개념이 없다면 같은 이름을 가진 변수끼리 충돌을 일으키므로 변수이름을 하나밖에 사용하지 못한다.


- 스코프 체인: 함수의 중첩에 의해 계층적 구조를 가진다
   - 모든 지역 스코프의 최상위 스코프는 전역스코프다!
- 변수를 참조할 때 자바스크립트 엔진은 변수 참조 코드 스코프에서 상위 스코프 방향으로 선언된 변수를 검색
- 상위 스코프에서 선언한 변수는 하위스코프에서 검색가능 <==> 하위스코프(지역)에서 선언된 변수는 상위스코프에서 검색불가능

**자바스크립트 엔진은 코드를 실행하기전에 렉시컬환경(구조)을 생성한다.** <br/>
 < 스코프체인은 실행컨텍스트의 렉시컬 환경을 단방향으로 연결한것이다.> 

## 함수 레벨 스코프

- 블록 레벨 스코프: 자바,C환경은 모든 코드 블록(if, for, while...)이 만드는 지역 스코프
   - 단 es6의 let, const 키워드는  블록 레벨 스코프를 지원
- 함수 레벨 스코프: var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하는 특성
```js
var x = 1;

if (true) {
    var x =10;
}
console.log(x); // 10
```
  
렉시컬 스코프 : 함수를 어디서 호출/정의 했는지 상위스코프를 결정한다.

# 14장: 전역 변수의 문제점

## 변수의 생명 주기
- 지역변수의 생명주기: 함수내부에서 선언된 지역변수는 함수가 종료되면 소멸한다.(메모리공간확보->메모리공간 해제(가용메모리 풀에 반환))
- 전역변수: 런타임 이전에 엔진에 의해 먼저 실행

### 전역 변수의 생명주기

- 전역변수는 코드가 로드되자마자 곧바로 해석되고 실행한다.
  - var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.(더이상 실행할 문이 없을경우에 종료된다.)
    <br/><br/>
- 전역 객체: 클라이언트 사이드 환경(브라우저)에서는 window, 서버사이드환경(Node.js)에서는 global 객체를 의미이다.
<br/><br/>
- 전역 변수의 문제점
  1. 암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경할 수 있음
  2. 긴 생명 주기: 변수이름 중복가능성으로 인한 재할당 문제
  3. 스코프 체인 상에서 종점에 존재: 전역변수의 검색속도 느림
  4. 네임스페이스 오염: 파일 분리되도 하나의 전역스코프를 공유

### 전역 변수의 사용을 억제하는 방법

- 즉시 실행 함수 : 한번만 사용
- 네임스페이스 객체 : 식별자 충돌 방지 (빈객체 사용으로 그떄마다 프로퍼티?를 추가)
- 모듈 패턴: 캡슐화를 통한 객체의 특정 프로퍼티를 은닉한다 이로인해 외부의 접근으로부터 내부를 보호할수 있다.


# 15장: let, const 키워드와 블록 레벨 스코프

### VAR 키워드의 문제점
1. 변수의 중복선언 허용
2. var키워드의 변수는 함수의 코드블록만을 지역스코프로 인정(함수외부는 모두 전역)
3. 변수 호이스팅에 의해 선언문이 선두로 끌려올려지는것처럼 동작한다.
```js
//먼저 변수 호이스팅에 의해 foo 변수가 선언! 1. 런타임전에 실행
//foo는 undefined로 초기화 2. 초기화
console.log(foo);//undefined
foo=123;//할당단계에서 값을 지정
console.log(foo);

var foo; // 런타임이전에 실행
``` 


## let 키워드

- 변수 중복 선언 금지: 중복 선언을 하게 되면 문법 에러

- 블록 레벨 스코프: 함수를 포함한 모든 코드블록 을 지역스코프로 인정

```js
//먼저 변수 호이스팅에 의해 foo 변수가 선언! 1. 런타임전에 실행
//초기화 이전에서는 변수를 참조할수 없다

console.log(foo);//참조오류 찾을수 없다

let foo //선언문에서 초기화단계

console.log(foo); //undefined

foo = 1 ; //할당문에서 값을 입력받음
``` 

var 키워드로 선언한 전역변수는 window의 프로퍼티가 되기때문에 window를 생략할수 있지만
let키워드는 '보이지 않는 개념적인 블록'에 존재하게 된다 그래서 window를 생략할수 없다.


## const 키워드

- 선언과 동시에 초기화
```js
const foo = 1; 
const foo // 문법 오류
```
- 블록 레벨 스코프, 호이스팅 발생하지 않는 것처럼 동작
- 재할당이 금지된다
- const키워드로 선언된 변수에 원시값(num,boolean등등)을 할당한 경우에는 변경불가능하지만
  변수에 객체를 할당하는 경우라면 값을 변경할수 있다. (객체는 변경가능한 값이기 때문에)
```js
const person={
    name:'lee'
}
person.name = 'kim'

console.log(person); //{name:'kim'}
```

es6를 사용한다면 var보다는 const를 사용하자!


