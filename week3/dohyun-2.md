# 16장: 프로퍼티 어리뷰트

## 내부 슬롯과 내부 메서드

- 내부슬롯과 내부 매서드는 개발자가 직접 접근하도록 외부로 공개된 객체의 프로퍼티는 아니다(js에서는 원칙적으로 접근하거나 호출할수있는 방법을 제공x)
<br/>
- ([[...]])으로 감싼 이름의 경우 __proto__를 통해 간접적으로 접근가능

## 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

 - 프로퍼티를 생성할떄 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동정의
    - 프로퍼티의 상태 [값],[갱신가능여부],[열거가능],[재정의가능여부]를 말한다.
 - 프로퍼티 어트리뷰트엔 직접 접근할수 없지만 아래방법을 사용하면 간접적으로 확인 가능

```js
const person = {
name:'Lee';
}
console.log(Object.getOwnPropertuDescriptor(person,'name'));
```

## 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 프로퍼티  // writable과 Configurable 의 차이점?
- 접근자 프로퍼티: 자체적으로 값을 갖지 않고, 다른 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
   - 값과 읽기전용대신 게터/세터 프로퍼티 어트리뷰트를 가지고 있다.

```js
const person = {
  // 데이터 프로퍼티
  firstName: 'ungmo',
  lastName: 'lee',

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  // setter 함수
  set fullName(name) {
    // 배열 디스트럭처링 할당
    [this.firstName, this.lastName] = name.split(' '); //fullname 재배치?
  }
};
person.fullName = "dohyun lee";
console.log(person.fullName); // dohyun lee   개터함수 호출
```

접근자 프로퍼티의 값에 접근하면 내부적으로 [[get]]내부 메서드의 동적 방식이다.

1. 프로퍼티 키 유효한지 확인 //이때 키의 형태는 string or symbol 이어야 하낟.
2. 프로토타입체인에서 프로퍼티 검색
3. 프로퍼티가 데이터 인지 접근자 인지 검색
4. 프로퍼티 어트리뷰트 [[Get]]의 값 getter 를 호출해 그 결과 반환  
   - 이때 get의 값은 프로퍼티 디스크립터의 get프로퍼티의 값과 같다.

> **프로토타입**
> - 객체의 부모 객체 역할을 하는 객체  //일단은 여기까지
> - 자세한건 19장에서 

## 프로퍼티 정의

- 프로퍼티 디스크리터 객체에서 생략된 어트리뷰트는 undefined or false로 적용된다.

## 객체 변경 방지

객체 변경을 방지하는 다양한 메서드 제공 

- 객체 확장 금지 `Object.preventExtensions`


- 객체 밀봉 `Object.seal`


- 객체 동결 `Object.freeze`


### 불변 객체

앞의 세 변경 방지 메서드는 직속 프로퍼티만 변경방지되고 중첩객체까지는 영향을 주지는 못하다.
중첩객체까지 동결하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.

```javascript
function deepFreeze(target) {
    if (target && typeof target === 'object' && !Object.isFrozen(target)) {
        Object.freeze(target);
        //모든 프로퍼티를 순회하며 동결한다.
      
        Object.keys(target).forEach(key => deepFreeze(target[key]));
        // Objects.key의 메서드는 객체자신의 열거가능한 프로퍼티키를 배열로 반환
      // for each 메서드는 배열을 순회하며 배열의 각요소에 대하여 콜백함수를 실행
    }
    return target;
}
```

# 17장: 생성자 함수에 의한 객체 생성

- 생성자 함수: new 연산자와 함께 호출해 객체를 생성하는 함수 
- 인스턴스: 생성자 함수에 의해 생성된 객체

## 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식의 문제점
   - 장점: 직관적이고 간편  
   - 단점: 단 하나의 객체만 생성, 여러 개 생성하려면 매번 같은 프로퍼티 기술해야 하기 때문에 비효울적이다.
- 생성자 함수에 의한 객체 생성 방식의 장점
   - 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용해 프로퍼티 구조가 동일한 객체 여러 개 생성 가능

##### this
  함수 호출방식  || this가 가리키는 값(this바인딩)
- 일반함수      : 전여 객체
- 메서드       : 메서드를 호출한 객체
- 생성자       : 생성자 함수가 생성할 인스턴스


### 생성자 함수의 인스턴스 생성 과정

```js
function Circle(radius) {
    //1. 암묵적으로 인스턴스 생성 및 this에 바인딩
  // 2. this에 바인딩되어있는 인스턴스를 초기화
    // 인스턴스 초기화
    this.radius = radius;
    this.getDiameter = function () {
        return 2 * this.radius;
    }
    // 3. 완성된 인스턴스가 바인딩된 this로 암묵적으로 반환
  
  //this 가 아닌 다른 객체를 명시적으로 반환하면 return값이 반환
  //return{}; // 빈객체 반환
  
  //원시값을 반환하면 원시값 무시
  //retrun 100;
}
// 인스턴스 생성!
const circle1 = new Circle(5);
```

### 내부 메서드  [[Call]]과 [[Construct]]
함수는 객체이므로 일반객체와 동일하게 동작할수 있다. 생성자 함수로서 호출한다는것은 new연산자와 함께 호철하여 객체생성하는 것을 의미

- 함수는 객체이지만 일반객체와는 다르다 // 함수객체는 일반객체가 가지고 있는 내부슬롯,메서드는 물론 동작하기 위해 객체만을 위한 [[환경]],[[formalparameters]]등의 내부슬롯과
  [[call]],[[construct]]같은 내부 메서드를 추가로 가지고 있다.

- 함수가 일반함수로 호출되면 내부메서드[[call]]가 호출되고 new 연산자와 함꼐 생성자 함수로서 생성되면 [[construct]]가 호출된다.

### constructor vs non-constructor

- 함수정의에 띠라 구분
  - constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
  - non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수 ()=>{}

new 없이 호출하면 일반 함수로 [[Call]] 호출.  
new 함께 호출하면 생성자 함수로서 [[Construct]] 호출. 이때 [[construct]]를 각지 않는다면 에러 발생


\* new 없이 호출했을 때 this는 전역 객체를 가리키기 때문에, 전역 객체의 프로퍼티와 메서드를 생성하는 효과가 날 수도 (예제 17-18)  
=> 생성자는 파스칼 케이스(첫 문자 대문자)로 명명해, 일반 함수와 구별해야

### new.target
es6에 도입된 문법이다.
- 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용, 메타 프로퍼티라고 부름
- new 연산자와 함께 생성자로 호출됐는지 확인할 수 있음
    - 생성자 함수로 호출 된 경우: new.target은 함수 자신
    - 일반 함수로 호출된 경우: new.target은 undefined

```js
function Circle(radius) {
    // 이 함수가 new와 함꼐 호출된 것이 아니라면
    if (!new.target) {
        // 직접 재귀 호출로 인스턴스를 생성해 반환한다
        return new Circle(radius);
    }
    this.radius = radius;
    this.getdiameter = function (){
        return 2*this.radius;
    }
}
```

# 18장: 함수와 일급 객체

## 일급 객체

- 일급객체의 조건 (4가지 다 갖출것)
   1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성 가능하다.
   2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
   3. 함수의 매개변수에 전달할 수 있다.
   4. 함수의 반환값으로 사용할 수 있다.

- 일급함수의 특징
  1. 일반객체와 가팅 함수의 매개변수 정달 가능
  2. 함수의 반환값으로 사용가능 
  3. 일반객체는 호출할수없지만 함수객체는 호출가능
  4. 함수객체는 일반객체에는 없는 함수고유의 프로퍼티를 소유


### arguments 프로퍼티

- value(값): arguments 객체
  - 함수 호출시 전달된 인수들의 정보를 담고있는 순회가능한 유사배열객체
  - 함수 내부에서 지역 변수처럼 사용돼 외부 참조 불가

  
### length 프로퍼티

함수를 정의할 때 선언한 매개변수의 개수


### name 프로퍼티

익명 함수 표현식의 경우 'ES5'에서는 빈문자열을 갖고, 'ES6'에서는 함수 객체를 가리키는 식별자를 값으로 갖는다. 



### \_\_proto_\_ 접근자 프로퍼티

모든 객체는 [[prototype]]이라는 내부 슬롯을 갖는다.
[[prototype]]내부 슬롯에도 직접적인 접근할수 없다
\_\_proto_\_ 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 간접적으로 접근하기 위해 사용하는 접근자 프로퍼티.



### prototype 프로퍼티

생성자함수로 호출할수 있는 함수(constructor)만이 소유하는 프로퍼티 
함수가 객체를 생성하는 생성자 함수로 호출될때 생성자함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.
