### 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 생성자 함수에 의해 생성된 인스턴스
  
  - constructor 프로퍼티가 가리키는 건(= 생성한 게 누구냐면) **인스턴스를 생성한 생성자 함수**

- 리터럴 표기에 의해 생성된 객체(인스턴스를 생성하지 않는 객체 생성)
  
  - constructor 프로퍼티가 가리키는 건(= 생성한 게 누구냐면) 객체를 생성한 생성자 함수라고 단정할 수 없다
    ex. 객체 리터럴로 생성한 객체는 Object 생성자 함수로 생성한 객체와 비교했을 때 세부 처리 내용이 다름  
  
  - 그렇지만 리터럴 표기로 생성한 객체나, 그렇지 않은 객체나 그 특성은 비슷 -> constructor가 같다고 치자
    ex. 객체 리터럴의 생성자 함수는 Object

### 19.5 프로토타입의 생성 시점

앞 장의 결론: **리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결됨**

-> 결국 모든 객체는 생성자 함수와 연결되어 있다.

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 
<- 프로토타입과 생성자 함수는 **쌍으로 존재**하니까

#### 사용자 정의 생성자 함수

- constructor(생성자 함수로서 호출할 수 있는 함수)
  
  - 함수 정의가 평가되어 함수 객체를 생성하는 시점(런타임 이전)에 프로토타입도 생성
  
  - 프로토타입도 프로토타입을 갖는다 - 이는 항상 Object.prototype

- non-constructor(생성자 함수로서 호출할 수 없는 함수 - 메서드 축약 표현, 화살표 함수)
  
  - 프로토타입이 생성되지 않는다

#### 빌트인 생성자 함수

- 빌트인 생성자 함수(Object, String, Number, Function, Array, RegExp, Date, Promise 등)
  
  - 모든 빌트인 생성자 함수는 전역 객체(브라우저의 window, Node.js 의 global)가 생성되는 시점 생성
  
  - 빌트인 생성자 함수가 생성되는 시점(= 전역 객체가 생성되는 시점 = 다른 객체들이 생성되기 이전)에 프로토타입 생성

=> 어떤 객체를 생성하면 이미 존재하고 있는 빌트인 생성자 함수의 프로토타입이 생성된 객체의 [[Prototype]] 내부 슬롯에 할당

### 19.6 객체 생성 방식과 프로토타입의 결정

객체 생성 방식(객체 리터럴 / Object 생성자 함수 / 생성자 함수 / Object.create 메서드 / 클래스) 공통점:  `OrdinaryObjectCreate`에 의해 생성

- 자신이 생성할 객체의 프로토타입을 인수로 전달받음

- 추가할 프로퍼티 목록을 옵션으로 전달할 수 있음

- 빈객체 생성 후, 추가 프로퍼티 목록이 있으면 프로퍼티를 객체에 추가 

- 인수인 프로토타입을 생성할 [[Prototype]] 내부 슬롯에 할당

- 생성한 객체 반환

=> 프로토타입은 OrdinaryObjectCreate 인수에 의해 결정

=> 이 인수는 객체 생성 시점에 생성 방식에 따라 결정

#### 객체 리터럴

OrdinaryObjectCreate 인수(프로토타입): Object.prototype

자체 constructor는 없지만 프로토타입의 constructor를 자기 것처럼 씀

```javascript
const obj = { x: 1 };
console.log(obj.constructor === Object); // true
```

#### Object 생성자 함수

OrdinaryObjectCreate 인수(프로토타입): Object.prototype

> 객체 리터럴 vs Object 생성자 함수
> 
> - 객체 리터럴: 내부에 프로퍼티 추가 
> 
> - Object 생성자 함수: 빈 객체 생성 이후 프로퍼티 

#### 생성자 함수

OrdinaryObjectCreate 인수(프로토타입): 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체

- Object.prototype에는 빌트인 메서드가 있지만, 사용자 정의 생성자 함수의 프로토타입은 기본적으로는 constructor 뿐이다. 

- 그렇지만 프로토타입 메서드를 추가하는 것도 가능하다.

- ```javascript
  function Person(name) {
      this.name = name;
  }
  
  Person.prototype.sayHello = function () {
      console.log(`Hi, I am ${this.name}`);
  };
  ```

### 19.7 프로토타입 체인

- 객체의 프로퍼티에 접근할 떄, 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색

- 자바스크립트가 객체지향 프로그램밍의 상속을 구현하는 메커니즘

- 프로토타입 체인 최상위 객체는 언제나 Object.prototype

- 그 종점에서도 프로퍼티 검색할 수 없으면 에러가 아닌 undefined를 반환 

c.f. 스코프체인: 식별자 검색을 위한 매커니즘(프로퍼티가 아닌 식별자는 스코프 체인에서 검색)

### 19.8 오버라이딩과 프로퍼티 섀도잉

- 프로토타입 프로퍼티: 프로토타입이 소유한 프로퍼티(메서드 포함)

- 인스턴스 프로퍼티: 인스턴스가 소유한 프로퍼티

- 프로퍼티 섀도잉: 상속 관계에 의해 프로퍼티가 가려지는 현상 
  
  - ex) 프로토타입 프로퍼티 sayHello가 있는 상테에서, 같은 이름으로 인스턴스에 프로퍼티를 추가할 경우 -> 프로토타입 프로퍼티 덮어쓰기 (X), 인스턴스 프로퍼티로 추가(O) 
    -> 인스턴스 메서드 sayHello가 프로퍼티 메서드 sayHello를 오버라이딩
    ->프로토타입 메서드 sayHello는 가려짐 
  
  - 섀도잉된 상태에서 삭제할 때는 인스턴스 메서드가 삭제되고 프로토타입 메서드는 남아있음
  
  - 프로토타입 프로퍼티를 삭제하려면 직접 프로토타입에 접근해야
    ex. `delete Person.prototype.sayHello`

c.f. 오버라이딩 vs 오버로딩

- 오버라이딩: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해 사용하는 방식

- 오버로딩: 함수 이름은 같지만 매개변수에 의해 메서드를 구별해 호출하는 방식

### 프로토타입의 교체

부모 객체인 프로토타입을 동적으로 변경할 수 있음 

#### 생성자 함수에 의한 프로토타입 교체

예제 19-41 생성자 함수가 왜 이렇게 생겼는지 모르겠다

#### 인스턴스에 의한 프로토타입 교체

```javascript
Object.setPrototypeOf(me, parent);
// me 객체의 프로토타입은 parent 객체로 교
```

객체의 프로토타입이 바뀌는 것이지, me의 원래 프로토타입인 Person이 영향을 받는 것은 아니다.

프로토타입 교체를 통해 객체간의 상속관계를 동적으로 변경하는 것은 꽤나 번거롭다.

따라서 **프로토타입은 직접 교체하지 않는 것이 좋다.**

### 19.10 instance of 연산자

`객체 instanceof 생성자 함수`

- true: 생성자 함수's prototype 객체가 좌변 객체의 프로토타입 체인 상에 존재할 때

- false: 그렇지 않을 때 
